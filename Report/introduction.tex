\section{Problem Statement}

Despite the abundance of devices nowadays, up until recently there was no way of sharing state information and I/O resources between devices. Although many users have access to multiple devices at the same time, e.g. their smartphone and laptop, those devices were mostly used independently. In the last few years, cross-device applications have become increasingly popular, facilitating the use of multiple devices at once by sharing data between them. The emergence of new web technologies such as Device APIs\footnote{\url{http://www.w3.org/2009/dap/}} and WebRTC\footnote{\url{http://www.webrtc.org/}} has made it possible to create a new generation of web-based frameworks that facilitate the development of cross-device applications. Such applications typically run on any device that has access to a modern web browser. Despite the large number of frameworks for developing cross-device applications, none of them have focused on testing and debugging cross-device applications.

However, there are already plenty of practical tools for testing and debugging web applications in general and many of them can be accessed directly from modern browsers. Google Chrome\footnote{\url{http://www.google.com/chrome/}} in particular, but to some extent also other browsers, provide quite mature tools for debugging JavaScript, HTML and CSS, but those tools are focused on debugging one device at a time.  However, today's devices have many different characteristics, mainly in terms of screen size, but also concerning their input capabilities and connectivity. This diversity of devices has made it a requirement to develop websites that are functional and appealing on all devices. This goal can be achieved by following the principles of responsive design. Many tools have emerged that support testing of such websites; some are already built into modern web browsers while others can be accessed through a website or by installing a program on a desktop PC. In summary, those tools use two different approaches for testing responsive websites: First, different devices can be emulated on a desktop computer. Second, a varied set of actual devices can be used. Google Chrome's Device Mode\footnote{\url{https://developer.chrome.com/devtools/docs/device-mode}} provides extensive support for emulating devices; apart from simply emulating the screen size, it can also emulate touch, varying network conditions, location, and more. Other browsers also provide basic facilities for device emulation. When using multiple devices, the developer has to refresh all devices individually whenever the web application has been modified. However, there exist a number of tools to facilitate this. Some allow the developer to reload all devices at once, e.g. Adobe Edge Inspect CC\footnote{\url{https://www.adobe.com/ch_de/products/edge-inspect.html}}, while others automatically reload devices when files change, e.g. BrowserSync\footnote{\url{http://www.browsersync.io/}}. Some of those tools even allow developers to simultaneously browse the web application on multiple devices. Apart from those tools, there are also web services for testing websites across multiple devices and platforms. Such web services typically include a screenshot generation service that renders a given website on a large number of devices. An example of such a web service is CrossBrowserTesting\footnote{\url{http://crossbrowsertesting.com/}}.

Those tools are already a good starting point for testing and debugging cross-device applications. However, cross-device applications and web applications targeted at one device at a time also have some fundamental differences that are not accounted for by those tools. In cross-device applications, multiple devices are typically used simultaneously and in a coordinated manner. Also, different devices do not necessarily show the same thing in cross-device applications, which limits the use of mirroring interactions from one device to all other devices. Furthermore, most of the tools for emulating devices focus on emulating one device at a time, which requires the developer to open multiple browser windows, possibly with different user profiles or in incognito mode, at a time, as cross-device applications only become useful when multiple devices are involved at once. Finally, all those tools focus either on emulating devices or on using real devices, but with cross-device applications, it might be desirable to combine those two approaches. Due to those differences, testing and debugging cross-device applications is usually still a challenging task. In the following section, we will describe what we plan to do to alleviate those differences. 

\section{Goal Statement}

In our project, we plan to make it easier to test and debug cross-device applications. The first step required for achieving this is to analyze the existing tools for debugging web applications. This includes tools built directly into browsers as well as external tools. In particular, tools for testing responsive web applications are also of interest, due to their similarities with cross-device applications. We will gather the limitations of those tools and try to find a solution that would make such tools more useful for testing cross-device applications. Furthermore, we will also analyze some frameworks for developing cross-device applications to see if they already provide any useful features for cross-device application testing. From this analysis, we will gather requirements for more suitable tools for cross-device application testing.

Based on those requirements, we will design and implement a new set of tools for testing and debugging cross-device applications. Those tools should allow testing applications both on real devices and emulated devices (possibly at the same time). Our goal is to provide as many useful features for testing cross-device applications as possible. Those features can include features from existing tools, features from existing tools that have been extended to suit the needs of cross-device application testing, as well as completely new features that might only make sense in a cross-device environment.

During the development of our tools, we will also implement two sample cross-device application using XD-MVC\footnote{\url{https://github.com/mhusm/XD-MVC}}, a cross-device application development framework. Those applications should help us in multiple ways with developing our tools: First, actually using our tools for developing cross-device applications might provide new ideas for crucial features that are still missing from our tools. Second, developing sample applications will also help us to improve existing features and might also reveal some bugs in existing features. Finally, we will also learn something about the usability of our tool.

Finally, we will conduct a user study to evaluate the usefulness and suitability of the tool, especially comparing to traditional methods of testing web applications. During this study, participants will get the opportunity to use our tools to implement a new feature in a cross-device application and to find and fix a bug. During this study, we will be able to find out if our tools are actually considered useful for testing cross-device applications by our participants. Furthermore, some participants might provide new ideas for features or improvements for our set of tools.

\section{Structure of this Document}

We conclude this chapter by giving an overview of the structure of this document:

In Chapter 2, we present the background  and related work of our project. In particular, we will describe existing tools for testing web applications as well as cross-device application development frameworks.

In Chapter 3, we describe our approach at achieving our goals and the requirements gathered during the analysis of related work.

In Chapter 4, we will describe the implementation of our set of tools in detail.

In Chapter 5, we will describe the sample applications that we developed and the insights we gained from them.

In Chapter 6, we will describe the user study and explain the results of it.

In Chapter 7, we conclude the work by showing what was achieved and what problems remain, and address possible future work that might be based on our existing set of tools.