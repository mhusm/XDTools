\section{Inclusion of Existing Features}

In the previous section, we have already describe some features that could also provide useful in a cross-device testing scenario. In particular, reloading all devices at once and loading a URL on all devices is important to responsive web applications as well as cross-device web application. Thus, our system includes those two features as well as the possibility of refreshing only one device or loading a URL on only one device.

\section{Emulation of Multiple Devices}

In current browsers, only one device can be emulated per tab. Additionally, some mechanism to ensure that each device has its own separate local resources such as local and session storage is required. Typically, multiple browser profiles, browser windows in incognito mode, or multiple independent browsers are used for this nowadays. Those two things both contribute significantly to the difficulty of testing cross-device applications. Thus, our set of tools conquers both those challenges. With our set of tools, the developer can emulate multiple devices simultaneously. This allows the developer to perform interactions on different devices and see their consequences on other devices without having to switch between browser windows or tabs. The developer can also switch the orientation of the devices, resize and scale the devices and move them as desired. Devices scaling allows the developer to decrease the size of devices to make space for more devices and increase the size if they want to perform some interactions on the device. Being able to resize the device makes it easy to see how the same application looks with different resolutions. The devices can be moved around arbitrarily, allowing the developer to completely customize their configuration. The system also ensures that all devices have their own separate local resources.

Similarly to existing tools for device emulations, the developer can select devices from a large list of predefined devices. This allows the developer to quickly select a specific device if required. Furthermore, the developer can create their own custom devices. Custom devices can either just be added as a custom emulated device to the current configuration, or they can be saved to the list of predefined devices and re-used later. New devices appear all the time and being able to quickly extend the list of predefined devices allows developers to easily test their applications on new devices.

\section{Easy Integration of Real and Emulated Devices}

Emulating devices is a versatile tool for testing cross-device applications on many different devices. However, it does not completely eliminate the need for testing on real devices: Even with the possibility of touch emulation in some device emulation tools, certain interactions will feel different on real devices than on emulated devices. An interaction that can easily be performed with the mouse might feel awkward on touch devices and vice-versa. Also, device emulation is always limited to certain aspects that are being emulated, e.g. screen size, resolution, touch interactions, location, and more. However, not every little detail of a real device can be emulated accurately and testing on real devices is crucial to successful development of cross-device applications. Thus, our system also allows to easily connect real devices. A real device can either be connected by scanning a QR code or by typing a URL in the browser of the device. As most devices nowadays are equipped with at least one camera, scanning a QR code provides an easy and less tedious way of opening an URL on a device. The real devices connected to our system can be used alongside emulated devices or on their own. They can be used just like the emulated devices.

\section{Easy Switching of Device Configurations}

In the real world, many different device scenarios can occur. The number of devices connected to a cross-device applications and their characteristics may vary greatly depending on the current users of the application. Depending on those devices, the UI distribution may be different. Also, some cross-device applications might be targeted to specific scenarios, e.g. a presentation room with multiple big screens that are always there, in addition to some mobile devices that are only in the room when their respective owner is attending a presentation. Our system allows the developer to quickly test different device scenarios: The user can quickly create some emulated devices, place them as desired on the screen and then save the configuration for later. Thus, the developer can quickly switch between different device scenarios. The developer can also create a device scenario where only static devices like in the presentation room scenario are saved in the configuration and then add other devices dynamically to represent a realistic scenario. 

\section{Integration with Debugging Tools}

Our system is tightly integrated with some existing tools for debugging. While debugging traditional web applications, logging messages to the console is often used for displaying some debugging information. However, when multiple browser windows/tabs are used, the console messages from each device have to be looked at separately. Since our system includes multiple emulated devices in one window, the console messages of all emulated devices are shown in the console. However, it is now difficult to identify the device where a particular message comes from. Thus, our system includes a custom console that aggregates the console messages from all devices, but also encodes them such that it is immediately clear which device the message was sent from. Furthermore, this console also includes logging messages from real devices that are connected to our system, thus no remote debugging is required for seeing those messages and they can be seen in the same window as the messages from emulated devices. Apart from logging messages used for debugging, all devices also forward any JavaScript errors that occur. Therefore, the developer can easily see if something goes wrong in the application and identify the device on which the error occurred. Similar to the console in Chrome DevTools, the messages in our console can also be filtered by type of message and/or by text. This is especially useful in a scenario where many devices are involved because otherwise it might be difficult to locate a specific message among a very large set of messages. Furthermore, the developer can send commands through the console. This command will be executed on all devices, or a subset of devices. It is important that the developer has the possibility to select a subset of devices because some things might only make sense on some devices in cross-device scenarios. Using traditional tools, the developer would have to send the command to each device individually. Apart from being more time-consuming, this might also cause problems because commands are performed sequentially on different devices instead of more or less synchronously. 

Most browsers also provide means for editing CSS from within the browser. This is a useful feature that allows users to quickly test their CSS on a device instead of having to change a file, save it, and reload the device. Similar to the JavaScript console, our system also extends the CSS editor to multiple devices. Our system provides a CSS editor that looks and feels somewhat similar to the CSS editors provided by browsers, but it applies all rules to all devices or a subset of devices. The CSS rules are applied to emulated devices as well as real devices automatically. The developer can deactivate rules temporarily, edit them, or remove them completely.

Another important feature of common debugging tools is debugging JavaScript. By setting breakpoints in functions, developers can debug their functions. Our system allows developers to add a function for debugging. The system then automatically sets a breakpoint at the beginning of the function for each device. This allows easy debugging of multiple devices at a time. Furthermore, if the function is called on any device, the device where it was called on is highlighted. Similarly, HTML and CSS debugging is also an important everyday task in web application development. Each emulated device in our system has a button that allows the developer to jump directly into the body of the HTML of the emulated device. Because multiple devices are emulated at the same time on our system, navigating to the correct device can be a tedious task that is greatly simplified with this feature. Due to the fact that the HTML and JavaScript of real devices cannot be investigated directly by opening the DevTools from our system, the two features described above only work on emulated devices. 

\section{Automatic Connection Management}

In order to use multiple devices in a cross-device application, those devices need to be connected in some way. The way that devices are connected can differ between different cross-device applications or cross-device application development framework. However, although the steps before that differ, our analysis has shown that for every cross-device application, the final pairing step requires opening a URL in the browser. In our system, this final step is completed automatically. Our system includes a customizable connection function that can be implemented by the developer of the cross-device application. Once this function is implemented, automatic connecting of devices becomes possible. The developer can set up the system to automatically connect all newly created devices to an existing device or they can choose the device to connect to manually.

\section{Coordinated Record and Replay}

Record and replay has already been used previously for recording and replaying user interactions and more. We believe that it provides even more value in a cross-device setting where it can be exploited to simulate multiple users interacting with an application at the same time. Our system allows users to record user interactions on arbitrary devices. Those interactions can then either be saved for later use or used directly for replaying. Event sequences can be cut into multiple parts and moved to other devices. The timing of the replays can be configured arbitrarily by dragging and dropping them. Thus, devices can be configured such that they replay interactions at the same time, one after another, or in any other way. This makes it easy to simulate multiple users using the devices or one user using multiple devices. Furthermore, breakpoints can be set at an arbitrary point of time. As soon as the events up to that point have been replayed, the replaying pauses and the developer can inspect the devices to see what is going on. 